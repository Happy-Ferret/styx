// type[2] dev[4] qid[13] mod[4] atime[4] mtime[4] length[8] name[s] uid[s] gid[s] muid[s

type parser struct {
	state     parserState
	mark, pos int64  // start and end+1 of dot
	msgSize   uint32 // size of the message
	msgType   uint8  // type of the message
	msgTag    uint16 // tag of the message
	err       error  // any error encountered
}

func (p *parser) advance(n int64)       { p.pos += n }
func (p *parser) setmark()              { p.mark = p.pos }
func (p *parser) dot(buf []byte) []byte { return buf[p.mark:p.pos] }

func (p *parser) guint16(buf []byte) uint16 {
	p.setmark()
	p.advance(2)
	return guint16(p.dot(buf))
}

func (p *parser) guint32(buf []byte) uint32 {
	p.setmark()
	p.advance(4)
	return guint32(p.dot(buf))
}

func (p *parser) done() bool {
	return p.state == stateCompleted ||
		p.state == stateParseError ||
		p.state == stateNeedMore
}



Gonna have to think over this abstraction again. Something
like

- Read as much available data into the buffer as will fit.
- Scan the buffer for message boundaries, doing
  rudimentary size checks based on type (just need first 5
  bytes of each message).
- Any Rread, Twrite messages that go off of the boundary
  are still considered complete.


The `bufio` package is full sized, might be better to use that
instead. Allows us to make small reads without worrying
about performance.

func castMessage(bytes []byte, buf fixedBuffer, r io.Reader) Msg {
	switch buf[5] {
	case msgRread:

		return Rread{msg: msg(buf)}
	case msgTwrite:
		return Twrite{msg: msg(buf)}
	case msgTversion:
		return Tversion(buf)
	case msgRversion:
		return Rversion(buf)
	case msgTauth:
		return Tauth(buf)
	case msgRauth:
		return Rauth(buf)
	case msgTattach:
		return Tattach(buf)
	case msgRattach:
		return Rattach(buf)
	case msgRerror:
		return Rerror(buf)
	case msgTflush:
		return Tflush(buf)
	case msgRflush:
		return Rflush(buf)
	case msgTwalk:
		return Twalk(buf)
	case msgRwalk:
		return Rwalk(buf)
	case msgTopen:
		return Topen(buf)
	case msgRopen:
		return Ropen(buf)
	case msgTcreate:
		return Tcreate(buf)
	case msgRcreate:
		return Rcreate(buf)
	case msgTread:
		return Tread(buf)
	case msgRwrite:
		return Rwrite(buf)
	case msgTclunk:
		return Tclunk(buf)
	case msgRclunk:
		return Rclunk(buf)
	case msgTremove:
		return Tremove(buf)
	case msgRremove:
		return Rremove(buf)
	case msgTstat:
		return Tstat(buf)
	case msgRstat:
		return Rstat(buf)
	case msgTwstat:
		return Twstat(buf)
	case msgRwstat:
		return Rwstat(buf)
	}
	panic("unknown message type")
}
